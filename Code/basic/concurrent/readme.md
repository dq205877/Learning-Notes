1、c_001

锁是锁定非null的this对象

2、c_002

锁this对象第二种写法

3、c_003

执行方法时锁定this对象

4、c_004

static synchronized(this,T.class)   不行，反射T.class就是好多this,静态方法不用对象

5、c_005

减了还未打印，线程又减，两个线程打印一样的值，就会存在打印的问题

6、c_006

加锁了则每恢复正常

7、c_007

非加锁方法可正常执行，因为本身都不用申请对象锁

27：32 tips

8、c_008

读不加锁写加锁有脏读

9、c_009

加锁方法再执行加锁方法是可以的，synchronized是重入锁

10、c_010

锁this对象，锁子类对象（允许），语法允许

11、c_011

出现异常时默认锁会被释放，所以有异常的情况要注意并发。（t1锁释放了导致了t2能运行了。）

12、c_012

volatile:线程可见/禁指令重排（主线程改状态了，但启动的线程看不到（自己的缓冲区状态没更新））循环中加入代码时，有可能CPU空闲了，线程缓冲区可能会去主内存刷新，但不能依赖这种不确定性。

13、c_013

volatile只保证可见性;不能替换synchronized，即可见，又原子。(值比实际小，因为可能多个线程读了相同的值)

14、c_014

与c_013对比

15、c_015

AtomicInteger 原子性，则有些情况不需要锁

两个原子性合并使用则不具备原子性了，中间会插入非原子操作（即需要锁）。

16、c_016

锁细化（细粒度锁），锁关键部分。

17、c_017

锁对象改变（堆内存中的对象，不是锁引用），对象改变则获取锁改变。

18、c_018

常量池，锁同一对象。（jetty出现过，很难发现）**（不要用字符串常量当锁对象）**

19、c_019

写同步容器

①线程没通信  add结束不了

②valotile  通信了 实现了（1不精确可能6执行2（加锁）2死循环浪费资源）

③wait（等并释放） notify（不释放锁）或notifyall（其中一个，所有）

④t2主动释放，t1再提醒

⑤门闩CountDownLatch

latch.await闩上  latch.countDown打开

**线程通信（共享内存（锁，notify/notify，while轮询），管道通信）**

20、c_020

可替代synchronized

ReentrantLock手动上锁释放!可设置公平和非公平。

lock.trylock可设超时

lock.lockInterruptibly锁得不到时可被打断（即不等了（没有限时的trylock)）

默认（synchronized是非公平锁，和时间没关系，效率较高）

21、c_021

wait和while一起使用，两次检查

22、c_022

不可见有不确定性，加了volatile一定不出错

不想让其他线程知道，ThreadLocal（空间换时间）可能会内存泄露

https://blog.csdn.net/puppylpg/article/details/80433271

23、c_023
内部类返回一个外部实例，不加锁方式实现懒加载单例

24、c_024

25、c_025